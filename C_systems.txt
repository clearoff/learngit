C语言知识体系

变量、常量、关键字和表达式
标记: 橙色

变量

编程语言最重要的概念之一

变量的声明

声明就是普通的声明，它所声明的并非本身，而是其他地方创建的对象

函数内部：局部变量                关键字：auto

局部变量只能在声明它的内部访问和引用，在其他块是不可知的，进入代码块时生成，退出代码块时销毁。

函数参数：形式参数

函数声明接收实参传值的变量，它的行为和局部变量一样

所有函数外部：全局变量

在程序运行时都占据空间

变量的定义

只能出现在一个地方，变量的定义确定变量的类型并为变量分配存储空间，相当于特殊的声明

常量

程序中最基本的元素

字符常量

有单引号括起来的字符

数值常量

有const修饰的变量、数值

枚举常量

enum 枚举常量，它的值为符号常量而不是字面值类型

宏定义的常量

#define Max_size 30  为数组命名一个符号

字符串常量

用一对双引号所包围的一串字符

常用关键字

最快的关键字：register

请求编译器尽可能将变量存储在cpu内部寄存器，而不是通过内存寻址访问

最名不副实的关键字：static

修饰变量

静态全部变量：该变量只能在文件内部使用，外部文件即使使用extern声明也无法使用它

静态局部变量：

该变量只能在所声明的函数内部使用，函数外部无法访问和引用

修饰函数

使得函数称为静态函数，对函数的作用于仅限于static声明函数的文件

const（readonly）：

const修饰的是变量而不是常量，其修饰的变量具有只读性

用途：

const修饰的变量保存在符号表中，编译器不为其分配空间，使得它的效率很高

最易变的关键字：volatile

是类型修饰符，volatile修饰的变量是随时可能发生变化的，降低了编译器对代码的优化以及内存的可见性

最会带帽子的关键字（extern）

可以定义在变量或函数前，表示该变量或函数在别的文件中已经定义了，同时，使用extern可以在一个文件中声明在另一个文件中定义的具有外部链接属性的变量

披着函数外衣的关键字（sizeof）:

sizeof是一个可以计算变量或类型所占内存空间大小的关键字，计算类型时括号不能省略

函数求值是在运行的时候，而关键字求值是在编译的时候，所以用sizeof()可以对越界的数组元素进行访问

伟大的缝纫师（typedef）:

给一个已经存在的类型取一个别名，常用语结构，联合中

表达式

表达式的求值

隐式类型转换

显式类型转换（强制转换）

操作符

算数操作符

+  —  *  /  %（其中，求余运算符只能用于两个整数之间的运算）

位操作符

按位与&		按位或|		按位异或^		按位取反~

移位运算符

左移<<:将操作符左边的数字在二进制下移动右边数字的位，高位丢弃，低位补0

右移>>:左边的运算数的各二进位全部右移若干位，“>>”右边的数指定移动的位数,有符号数右移时，符号位跟着移动，为整数时，高位补0，为负数时，取决于编译器

左移和右移的位数不能大于数据的长度，不能小于0。

逻辑运算符

逻辑或 ||

逻辑运算符||两边的条件只要有一个为真，其结果就为真，也就是说，只要||运算符的第一个表达式为真，后面的表达式便不参与运算，使用时应当注意

逻辑与 &&

只要有一个结果为假，其结果就为假，只要第一个结果为假，便不再计算&&右边的表达式

关系操作符

0与浮点数进行比较：（设置精度）

布尔值的比较

始终把表示布尔值的变量设置成0或者1

指针与0值进行比较

与NULL进行比较

逗号操作符

自左向右逐个求值，整个逗号表达式的值就是最后那个表达式的值

条件操作符

expression1 ? expression2:expression3

语句

空语句

不执行任何任务，只包含一个分号，是最简单的语句

代码块

位于一对花括号之间的可选的声明和语句列表

控制语句

判断语句

if   else    else if

循环语句

do{   ; }while(statement);

循环语句至少执行一次

while(statement){   循环体}

在循环语句开始之前就开始进行测试

for(statement1;statement2;statement3){   循环体 }

第一个条件只执行一次，在进入循环体之前先判断第二个表达式是否为真，执行完循环体后再执行第三个表达式

分支结构语句

switch语句

  switch(expression)  expression表达式的结果必须是一个整型值，switch语句代码块中包含了case flag:  和default ：语句   ,其中case后面的标签必须是一个常量或常量表达式，不能是const修饰的变量，另外  case语句和default语句中，应使用break语语句来跳出case.  

函数

函数定义：

TYPE  函数名（形式参数）代码块

形参包括了变量名和变量的类型声明，代码块包含了局部变量的声明，以及调用函数所需要执行的代码块

函数声明：

向编译器提供一些关于函数的特定信息，编译器得到该函数的信息会检查函数的后续调用，如果调用在定义前面则必须要声明。

编译器在每个函数结束前会把它记住的原型信息丢弃，避免发现函数之间存在的不匹配情况

函数的缺省认定：

当编译器无法见到原型的函数（函数的类型），会自动认定函数的返回值为整形

函数参数：

传参方式：

所有函数都是传值调用，形参在传参后得到的是实参的一份拷贝

传递给函数数组参数在行为上相当于传地址，实际上却是传值

函数的递归：

C通过运行时堆栈支持递归函数的实现，递归函数就是直接或间接调用自身的函数

可变参数列表：

stdarg宏（定义在stdarg.h）的头文件中：

va_list类型

可以声明一个变量，来访问参数列表中的未确定部分

va_start

va_list声明的变量通过调用va_start来进行初始化：va_start(var_arg,n_values);   var_arg是va_list所声明的变量，n_value是省略号前最后一个有名字的参数，va_start将var_arg指向可变参数列表的第一个参数

va_end

访问完最后一个参数后，需要使用va_end来访问完毕

va_arg

这个宏用于访问变量，va_arg(var_arg,type)     其中var_arg 是va_list声明的变量，type是参数列表中的下一个参数的类型

运行时环境：

翻译环境：

环境中源代码被转化为可执行的机器指令

1：源文件通过编译转化成源代码

2：每个文件由链接器捆绑在一起

关于文件名约定：

1：C的源代码保存在.C扩展名命名的文件当中

2：头文件保存于扩展名为.h扩展名的文件当中

3：产生的目标文件在UNIX下为.o   在windows下为.obj

编译链接：

1：预编译

1：#define 替换     2：#include文件包含       3：消除注释

2:编译

1：语法分析   2：语义分析     3：符号汇总    4：词法分析    并把文本语言转化成汇编语言   （*.i------>*.s)

3：汇编

1:产生的目标文件在UNIX下为.o   在windows下为.obj      2:形成符号表（只读常量）     3：汇编指令转化成二进制指令

4：链接

1：合并段表        2：符号表的合并和符号表的重定位      3：生成可执行文件   （windows下生成*.exe   UNIX下生成/a.out）

执行环境：

用于执行实际代码

程序执行的过程：

1；程序由操作系统载入内存中

2：程序执行开始，接着便由_mainCRTStartup函数调用main函数

3：开始执行程序代码，程序将使用运行时堆栈存储函数的局部变量和返回地址，程序同时也开辟静态内存，存储静态内存中的变量，并在整个程序执行的过程中一直保留它们的值

4:终止程序

函数的调用过程

函数调用原理——栈帧

栈的生长:向下生长，即内存由高地址向低地址延伸

寄存器ebp:未受改变之前始终指向栈底（栈帧的开始），在堆栈中作为寻址使用

寄存器esp:esp会随着数据的入栈和出栈移动，其始终指向栈顶

函数调用的过程：

1：先将调用函数的堆栈的基址（ebp）入栈，保存调用函数之前任务的信息。

2：然后将调用者的栈顶指针esp的值付给ebp,作为新的基址

3:然后再被调用者的基址上开辟（sub）相应的空间用作被调用者的栈空间（esp上移）

4：被调用函数返回后，从当前栈帧的ebp恢复为调用函数的栈顶，使栈顶恢复调用被调用函数调用之前的位置，然后调用函数再从恢复后的栈顶弹出之前ebp的值

main函数的参数（命令行参数）：

int argc:

表示命令行参数的数目

char *argc[ ]:

指针数组，指向命令行参数的首元素

数组



数组名：

通过指定数组名，可以生成指向第一个元素的指针

数组名的降级：

为什么数组名会发生降级：为了降低内存的消耗

数组名发生降级的场合：除了数组名单独使用和取&不会发生降级外，其他场合均会发生降级

&a 和 &a[0] 的区别：

&a是数组的首地址   &a[0]是数组首元素的首地址

数组名不能作为左值，作为右值时（代表）数组首元素的地址

指针与数组的关系：

访问：

以指针形式访问和以数组形式访问本质上是相同的

把任何东西赋值给指针变量都会被当作地址处理，而数组元素只能接受相同类型的赋值

定义为数组，声明为指针：

数组中的前四个元素被当作指针变量的地址来处理，但该地址可能为NULL，对其访问程序可能会崩溃

定义为指针，声明为数组：

数组把指针变量所存储的地址按适当的类型存储到数组中，使程序不能直接对所定义的数组进行直接访问

数组通常用于存储固定长度的元素，而指针常用语动态数据结构

指针（int *p）:

p为指针变量，它指向类型为int 类型的变量的地址，通过*p可以获得这块地址的内容

指针的大小：无论什么类型的指针变量，它的大小都为4个字节

指针数组：

是一个数组，数组的元素是指针

声明：Type *arr[ ]；

数组指针：

是一个指针，它指向一个数组。

数组指针的类型     type (*)[数组元素的个数]

函数指针：

是一个指针 ，指向一个函数

声明： Type1  (*pf)(Type2...); //Type1为函数返回值的类型，Type2为函数参数的类型

调用:pf=&f    //f为函数名，其中&操作是可选的，因为函数名单独使用时，编译器会把他转换为函数指针

函数指针数组（用来存放函数指针的数组）： Type *(*[N])(Type....);

内存管理

什么是野指针：

定义指针变量时赋值NULL，使用完指针变量是赋值NULL，可防止野指针对程序的影响

堆、栈、静态区：

堆：

由malloc和new系列操作符所分配的内存，其生命周期取决于free();  并且在没有释放之前一直存在

栈：

存储函数内部的局部变量，声明周期是函数调用结束

静态区：

主要用来存储自动全局变量和静态变量（static），其生命周期是整个程序

函数入口检验：

assert(NULL!=指针变量)；  //assert()是一个宏不是函数

内存泄漏：

堆上的内存容易产生内存泄漏，使用动态内存函数开辟的内存没有被释放，一直到程序终止，这个过程就叫做内存泄漏

malloc系列函数：

void *malloc( size_t size ); ：

void *realloc( void *memblock, size_t size ); ：

可以在原来开辟的内存上接着开辟，但新开辟的空间是原来内存的大小和接着开辟内存大小的总和

void *calloc( size_t num, size_t size ); ：

开辟size个字节的空间，并且将这些空间上的内容自动初始化为0

一次malloc一次free  否则会造成内存泄漏或者程序崩溃

预处理

预处理是指编译器在编译之前对目标文件所进行的一些文本性的操作

预处理符号：

_FILE_ _DATA_ _LINE_ _TIME_ _STDC_

#define(宏替换) :

在预处理阶段，编译器通过宏替换将所定义的字符串替换成真身

把宏参数插入到字符串中：

编译器把#arguement翻译为argument

##:

把位于其两边的符号连接成一个符号

#undef:

undef用于移除一个宏定义

条件编译：

选择一部分代码被正常编译还是忽略

利用条件编译可以防止宏的重定义
